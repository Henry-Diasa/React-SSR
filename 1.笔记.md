# webpack-node-externals

# npm-run-all
// 并行执行两个 命令的脚本

# weback target 的配置
target

# weback watch 的配置
watch

# dev
npm-run-all --parallel dev:*

# cors 库的使用


# node 服务器去代理接口服务器.


#######  S1 #######
渲染 dom 节点
#######  S2 #######
事件怎么办???
所有关于dom 的操作都只能够在浏览器处绑定
绑定事件是 服务器端渲染 搞不定的.
服务器端只会首屏!  只负责首屏的dom 渲染.

#######  S3 #######
实现路由,
如何在服务器 渲染的项目中,实现路由

客户端 路由   BrowserRouter
服务器 路由   StaticRouter


#######  S4 #######
路由渲染完了是 Redux
服务端渲染 和 Redux 如何在服务器端使用 Redux

#######  S5 #######
store 
这边需要有两个 获取仓库的 方法

getSeverStore
getClientStore


#######   S6 #######
如何异步去获得接口  
服务器端和 浏览器端是有差别的

服务器端把 读取的内容 渲染到 浏览器上面.

路由配置的改写.

s3: 如何把服务器端的仓库发给浏览器端呢?
在 render 的 模板中
把  sate 挂载到浏览器的window 对象下面

window.context = {

}

#######   S6 #######
处理多级路由问题.








# render.js
多 提取内容. 多多提取相关文件

# StaticRouter 的使用.
<StaticRouter context={{}} location={} ></StaticRouter>
这边的 context 是服务器端和浏览器端 通信用的
context 304 跳转和 404 跳转
以及 样式都是靠 context 来实现的



# 注意点:
Warning: render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v17. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.

hydrate: 水合物!

hydrate  和 render 的区别! 和作用!
hydrate: 当服务器端已经渲染除了 dom 的话就 直接绑定js 事件 而不去影响dom 元素了!


# 
Invariant Violation: Could not find "store" in the context of "Connect(Home)". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to Connect(Home) in connect options.
  
# warning
Did not expect server HTML to contain a <li> in <ul>.
<!-- 
  服务器端是 在ul 有的,
  但是 在 客户端 渲染的时候, 却有 没有li了

  主要的原因就是  服务器已经渲染了这些 dom 元素了
  你们 浏览器端再 进行渲染的话就是 重复渲染了.  是非常没有必要的.
 -->


# matchPath  react-router 中 中 matchPath 这一个api 的使用
